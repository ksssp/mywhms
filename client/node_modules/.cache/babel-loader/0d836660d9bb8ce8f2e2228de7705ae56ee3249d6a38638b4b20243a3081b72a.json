{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*! ColReorder 1.6.2\n * © SpryMedia Ltd - datatables.net/license\n */\n\nimport $ from 'jquery';\nimport DataTable from 'datatables.net';\n\n/**\n * @summary     ColReorder\n * @description Provide the ability to reorder columns in a DataTable\n * @version     1.6.2\n * @author      SpryMedia Ltd\n * @contact     datatables.net\n * @copyright   SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n\n/**\n * Switch the key value pairing of an index array to be value key (i.e. the old value is now the\n * key). For example consider [ 2, 0, 1 ] this would be returned as [ 1, 2, 0 ].\n *  @method  fnInvertKeyValues\n *  @param   array aIn Array to switch around\n *  @returns array\n */\nfunction fnInvertKeyValues(aIn) {\n  var aRet = [];\n  for (var i = 0, iLen = aIn.length; i < iLen; i++) {\n    aRet[aIn[i]] = i;\n  }\n  return aRet;\n}\n\n/**\n * Modify an array by switching the position of two elements\n *  @method  fnArraySwitch\n *  @param   array aArray Array to consider, will be modified by reference (i.e. no return)\n *  @param   int iFrom From point\n *  @param   int iTo Insert point\n *  @returns void\n */\nfunction fnArraySwitch(aArray, iFrom, iTo) {\n  var mStore = aArray.splice(iFrom, 1)[0];\n  aArray.splice(iTo, 0, mStore);\n}\n\n/**\n * Switch the positions of nodes in a parent node (note this is specifically designed for\n * table rows). Note this function considers all element nodes under the parent!\n *  @method  fnDomSwitch\n *  @param   string sTag Tag to consider\n *  @param   int iFrom Element to move\n *  @param   int Point to element the element to (before this point), can be null for append\n *  @returns void\n */\nfunction fnDomSwitch(nParent, iFrom, iTo) {\n  var anTags = [];\n  for (var i = 0, iLen = nParent.childNodes.length; i < iLen; i++) {\n    if (nParent.childNodes[i].nodeType == 1) {\n      anTags.push(nParent.childNodes[i]);\n    }\n  }\n  var nStore = anTags[iFrom];\n  if (iTo !== null) {\n    nParent.insertBefore(nStore, anTags[iTo]);\n  } else {\n    nParent.appendChild(nStore);\n  }\n}\n\n/**\n * Plug-in for DataTables which will reorder the internal column structure by taking the column\n * from one position (iFrom) and insert it into a given point (iTo).\n *  @method  $.fn.dataTableExt.oApi.fnColReorder\n *  @param   object oSettings DataTables settings object - automatically added by DataTables!\n *  @param   int iFrom Take the column to be repositioned from this point\n *  @param   int iTo and insert it into this point\n *  @param   bool drop Indicate if the reorder is the final one (i.e. a drop)\n *    not a live reorder\n *  @param   bool invalidateRows speeds up processing if false passed\n *  @returns void\n */\n$.fn.dataTableExt.oApi.fnColReorder = function (oSettings, iFrom, iTo, drop, invalidateRows) {\n  var i,\n    iLen,\n    j,\n    jLen,\n    jen,\n    iCols = oSettings.aoColumns.length,\n    nTrs,\n    oCol;\n  var attrMap = function (obj, prop, mapping) {\n    if (!obj[prop] || typeof obj[prop] === 'function') {\n      return;\n    }\n    var a = obj[prop].split('.');\n    var num = a.shift();\n    if (isNaN(num * 1)) {\n      return;\n    }\n    obj[prop] = mapping[num * 1] + '.' + a.join('.');\n  };\n\n  /* Sanity check in the input */\n  if (iFrom == iTo) {\n    /* Pointless reorder */\n    return;\n  }\n  if (iFrom < 0 || iFrom >= iCols) {\n    this.oApi._fnLog(oSettings, 1, \"ColReorder 'from' index is out of bounds: \" + iFrom);\n    return;\n  }\n  if (iTo < 0 || iTo >= iCols) {\n    this.oApi._fnLog(oSettings, 1, \"ColReorder 'to' index is out of bounds: \" + iTo);\n    return;\n  }\n\n  /*\n   * Calculate the new column array index, so we have a mapping between the old and new\n   */\n  var aiMapping = [];\n  for (i = 0, iLen = iCols; i < iLen; i++) {\n    aiMapping[i] = i;\n  }\n  fnArraySwitch(aiMapping, iFrom, iTo);\n  var aiInvertMapping = fnInvertKeyValues(aiMapping);\n\n  /*\n   * Convert all internal indexing to the new column order indexes\n   */\n  /* Sorting */\n  for (i = 0, iLen = oSettings.aaSorting.length; i < iLen; i++) {\n    oSettings.aaSorting[i][0] = aiInvertMapping[oSettings.aaSorting[i][0]];\n  }\n\n  /* Fixed sorting */\n  if (oSettings.aaSortingFixed !== null) {\n    for (i = 0, iLen = oSettings.aaSortingFixed.length; i < iLen; i++) {\n      oSettings.aaSortingFixed[i][0] = aiInvertMapping[oSettings.aaSortingFixed[i][0]];\n    }\n  }\n\n  /* Data column sorting (the column which the sort for a given column should take place on) */\n  for (i = 0, iLen = iCols; i < iLen; i++) {\n    oCol = oSettings.aoColumns[i];\n    for (j = 0, jLen = oCol.aDataSort.length; j < jLen; j++) {\n      oCol.aDataSort[j] = aiInvertMapping[oCol.aDataSort[j]];\n    }\n\n    // Update the column indexes\n    oCol.idx = aiInvertMapping[oCol.idx];\n  }\n\n  // Update 1.10 optimised sort class removal variable\n  $.each(oSettings.aLastSort, function (i, val) {\n    oSettings.aLastSort[i].src = aiInvertMapping[val.src];\n  });\n\n  /* Update the Get and Set functions for each column */\n  for (i = 0, iLen = iCols; i < iLen; i++) {\n    oCol = oSettings.aoColumns[i];\n    if (typeof oCol.mData == 'number') {\n      oCol.mData = aiInvertMapping[oCol.mData];\n    } else if ($.isPlainObject(oCol.mData)) {\n      // HTML5 data sourced\n      attrMap(oCol.mData, '_', aiInvertMapping);\n      attrMap(oCol.mData, 'filter', aiInvertMapping);\n      attrMap(oCol.mData, 'sort', aiInvertMapping);\n      attrMap(oCol.mData, 'type', aiInvertMapping);\n    }\n  }\n\n  /*\n   * Move the DOM elements\n   */\n  if (oSettings.aoColumns[iFrom].bVisible) {\n    /* Calculate the current visible index and the point to insert the node before. The insert\n     * before needs to take into account that there might not be an element to insert before,\n     * in which case it will be null, and an appendChild should be used\n     */\n    var iVisibleIndex = this.oApi._fnColumnIndexToVisible(oSettings, iFrom);\n    var iInsertBeforeIndex = null;\n    i = iTo < iFrom ? iTo : iTo + 1;\n    while (iInsertBeforeIndex === null && i < iCols) {\n      iInsertBeforeIndex = this.oApi._fnColumnIndexToVisible(oSettings, i);\n      i++;\n    }\n\n    /* Header */\n    nTrs = oSettings.nTHead.getElementsByTagName('tr');\n    for (i = 0, iLen = nTrs.length; i < iLen; i++) {\n      fnDomSwitch(nTrs[i], iVisibleIndex, iInsertBeforeIndex);\n    }\n\n    /* Footer */\n    if (oSettings.nTFoot !== null) {\n      nTrs = oSettings.nTFoot.getElementsByTagName('tr');\n      for (i = 0, iLen = nTrs.length; i < iLen; i++) {\n        fnDomSwitch(nTrs[i], iVisibleIndex, iInsertBeforeIndex);\n      }\n    }\n\n    /* Body */\n    for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {\n      if (oSettings.aoData[i].nTr !== null) {\n        fnDomSwitch(oSettings.aoData[i].nTr, iVisibleIndex, iInsertBeforeIndex);\n      }\n    }\n  }\n\n  /*\n   * Move the internal array elements\n   */\n  /* Columns */\n  fnArraySwitch(oSettings.aoColumns, iFrom, iTo);\n\n  // regenerate the get / set functions\n  for (i = 0, iLen = iCols; i < iLen; i++) {\n    oSettings.oApi._fnColumnOptions(oSettings, i, {});\n  }\n\n  /* Search columns */\n  fnArraySwitch(oSettings.aoPreSearchCols, iFrom, iTo);\n\n  /* Array array - internal data anodes cache */\n  for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {\n    var data = oSettings.aoData[i];\n    var cells = data.anCells;\n    if (cells) {\n      fnArraySwitch(cells, iFrom, iTo);\n\n      // Longer term, should this be moved into the DataTables' invalidate\n      // methods?\n      for (j = 0, jen = cells.length; j < jen; j++) {\n        if (cells[j] && cells[j]._DT_CellIndex) {\n          cells[j]._DT_CellIndex.column = j;\n        }\n      }\n    }\n\n    // Swap around array sourced data (object based is left as is)\n    if (Array.isArray(data._aData)) {\n      fnArraySwitch(data._aData, iFrom, iTo);\n    }\n  }\n\n  /* Reposition the header elements in the header layout array */\n  for (i = 0, iLen = oSettings.aoHeader.length; i < iLen; i++) {\n    fnArraySwitch(oSettings.aoHeader[i], iFrom, iTo);\n  }\n  if (oSettings.aoFooter !== null) {\n    for (i = 0, iLen = oSettings.aoFooter.length; i < iLen; i++) {\n      fnArraySwitch(oSettings.aoFooter[i], iFrom, iTo);\n    }\n  }\n  if (invalidateRows || invalidateRows === undefined) {\n    // Always read from the data object rather than reading back from the DOM\n    // since it could have been changed by a renderer\n    $.fn.dataTable.Api(oSettings).rows().invalidate('data');\n  }\n\n  /*\n   * Update DataTables' event handlers\n   */\n\n  /* Sort listener */\n  for (i = 0, iLen = iCols; i < iLen; i++) {\n    $(oSettings.aoColumns[i].nTh).off('.DT');\n    this.oApi._fnSortAttachListener(oSettings, oSettings.aoColumns[i].nTh, i);\n  }\n\n  /* Fire an event so other plug-ins can update */\n  $(oSettings.oInstance).trigger('column-reorder.dt', [oSettings, {\n    from: iFrom,\n    to: iTo,\n    mapping: aiInvertMapping,\n    drop: drop,\n    // Old style parameters for compatibility\n    iFrom: iFrom,\n    iTo: iTo,\n    aiInvertMapping: aiInvertMapping\n  }]);\n};\n\n/**\n * ColReorder provides column visibility control for DataTables\n * @class ColReorder\n * @constructor\n * @param {object} dt DataTables settings object\n * @param {object} opts ColReorder options\n */\nvar ColReorder = function (dt, opts) {\n  var settings = new $.fn.dataTable.Api(dt).settings()[0];\n\n  // Ensure that we can't initialise on the same table twice\n  if (settings._colReorder) {\n    return settings._colReorder;\n  }\n\n  // Allow the options to be a boolean for defaults\n  if (opts === true) {\n    opts = {};\n  }\n\n  // Convert from camelCase to Hungarian, just as DataTables does\n  var camelToHungarian = $.fn.dataTable.camelToHungarian;\n  if (camelToHungarian) {\n    camelToHungarian(ColReorder.defaults, ColReorder.defaults, true);\n    camelToHungarian(ColReorder.defaults, opts || {});\n  }\n\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Public class variables\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n  /**\n   * @namespace Settings object which contains customisable information for ColReorder instance\n   */\n  this.s = {\n    /**\n     * DataTables settings object\n     *  @property dt\n     *  @type     Object\n     *  @default  null\n     */\n    \"dt\": null,\n    /**\n     * Enable flag\n     *  @property dt\n     *  @type     Object\n     *  @default  null\n     */\n    \"enable\": null,\n    /**\n     * Initialisation object used for this instance\n     *  @property init\n     *  @type     object\n     *  @default  {}\n     */\n    \"init\": $.extend(true, {}, ColReorder.defaults, opts),\n    /**\n     * Number of columns to fix (not allow to be reordered)\n     *  @property fixed\n     *  @type     int\n     *  @default  0\n     */\n    \"fixed\": 0,\n    /**\n     * Number of columns to fix counting from right (not allow to be reordered)\n     *  @property fixedRight\n     *  @type     int\n     *  @default  0\n     */\n    \"fixedRight\": 0,\n    /**\n     * Callback function for once the reorder has been done\n     *  @property reorderCallback\n     *  @type     function\n     *  @default  null\n     */\n    \"reorderCallback\": null,\n    /**\n     * @namespace Information used for the mouse drag\n     */\n    \"mouse\": {\n      \"startX\": -1,\n      \"startY\": -1,\n      \"offsetX\": -1,\n      \"offsetY\": -1,\n      \"target\": -1,\n      \"targetIndex\": -1,\n      \"fromIndex\": -1\n    },\n    /**\n     * Information which is used for positioning the insert cusor and knowing where to do the\n     * insert. Array of objects with the properties:\n     *   x: x-axis position\n     *   to: insert point\n     *  @property aoTargets\n     *  @type     array\n     *  @default  []\n     */\n    \"aoTargets\": []\n  };\n\n  /**\n   * @namespace Common and useful DOM elements for the class instance\n   */\n  this.dom = {\n    /**\n     * Dragging element (the one the mouse is moving)\n     *  @property drag\n     *  @type     element\n     *  @default  null\n     */\n    \"drag\": null,\n    /**\n     * The insert cursor\n     *  @property pointer\n     *  @type     element\n     *  @default  null\n     */\n    \"pointer\": null\n  };\n\n  /* Constructor logic */\n  this.s.enable = this.s.init.bEnable;\n  this.s.dt = settings;\n  this.s.dt._colReorder = this;\n  this._fnConstruct();\n  return this;\n};\n$.extend(ColReorder.prototype, {\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Public methods\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n  /**\n   * Enable / disable end user interaction\n   */\n  fnEnable: function (flag) {\n    if (flag === false) {\n      return this.fnDisable();\n    }\n    this.s.enable = true;\n  },\n  /**\n   * Disable end user interaction\n   */\n  fnDisable: function () {\n    this.s.enable = false;\n  },\n  /**\n   * Reset the column ordering to the original ordering that was detected on\n   * start up.\n   *  @return {this} Returns `this` for chaining.\n   *\n   *  @example\n   *    // DataTables initialisation with ColReorder\n   *    var table = $('#example').dataTable( {\n   *        \"sDom\": 'Rlfrtip'\n   *    } );\n   *\n   *    // Add click event to a button to reset the ordering\n   *    $('#resetOrdering').click( function (e) {\n   *        e.preventDefault();\n   *        $.fn.dataTable.ColReorder( table ).fnReset();\n   *    } );\n   */\n  \"fnReset\": function () {\n    this._fnOrderColumns(this.fnOrder());\n    return this;\n  },\n  /**\n   * `Deprecated` - Get the current order of the columns, as an array.\n   *  @return {array} Array of column identifiers\n   *  @deprecated `fnOrder` should be used in preference to this method.\n   *      `fnOrder` acts as a getter/setter.\n   */\n  \"fnGetCurrentOrder\": function () {\n    return this.fnOrder();\n  },\n  /**\n   * Get the current order of the columns, as an array. Note that the values\n   * given in the array are unique identifiers for each column. Currently\n   * these are the original ordering of the columns that was detected on\n   * start up, but this could potentially change in future.\n   *  @return {array} Array of column identifiers\n   *\n   *  @example\n   *    // Get column ordering for the table\n   *    var order = $.fn.dataTable.ColReorder( dataTable ).fnOrder();\n   */ /**\n      * Set the order of the columns, from the positions identified in the\n      * ordering array given. Note that ColReorder takes a brute force approach\n      * to reordering, so it is possible multiple reordering events will occur\n      * before the final order is settled upon.\n      *  @param {array} [set] Array of column identifiers in the new order. Note\n      *    that every column must be included, uniquely, in this array.\n      *  @return {this} Returns `this` for chaining.\n      *\n      *  @example\n      *    // Swap the first and second columns\n      *    $.fn.dataTable.ColReorder( dataTable ).fnOrder( [1, 0, 2, 3, 4] );\n      *\n      *  @example\n      *    // Move the first column to the end for the table `#example`\n      *    var curr = $.fn.dataTable.ColReorder( '#example' ).fnOrder();\n      *    var first = curr.shift();\n      *    curr.push( first );\n      *    $.fn.dataTable.ColReorder( '#example' ).fnOrder( curr );\n      *\n      *  @example\n      *    // Reverse the table's order\n      *    $.fn.dataTable.ColReorder( '#example' ).fnOrder(\n      *      $.fn.dataTable.ColReorder( '#example' ).fnOrder().reverse()\n      *    );\n      */\n  \"fnOrder\": function (set, original) {\n    var a = [],\n      i,\n      ien,\n      j,\n      jen;\n    var columns = this.s.dt.aoColumns;\n    if (set === undefined) {\n      for (i = 0, ien = columns.length; i < ien; i++) {\n        a.push(columns[i]._ColReorder_iOrigCol);\n      }\n      return a;\n    }\n\n    // The order given is based on the original indexes, rather than the\n    // existing ones, so we need to translate from the original to current\n    // before then doing the order\n    if (original) {\n      var order = this.fnOrder();\n      for (i = 0, ien = set.length; i < ien; i++) {\n        a.push($.inArray(set[i], order));\n      }\n      set = a;\n    }\n    this._fnOrderColumns(fnInvertKeyValues(set));\n    return this;\n  },\n  /**\n   * Convert from the original column index, to the original\n   *\n   * @param  {int|array} idx Index(es) to convert\n   * @param  {string} dir Transpose direction - `fromOriginal` / `toCurrent`\n   *   or `'toOriginal` / `fromCurrent`\n   * @return {int|array}     Converted values\n   */\n  fnTranspose: function (idx, dir) {\n    if (!dir) {\n      dir = 'toCurrent';\n    }\n    var order = this.fnOrder();\n    var columns = this.s.dt.aoColumns;\n    if (dir === 'toCurrent') {\n      // Given an original index, want the current\n      return !Array.isArray(idx) ? $.inArray(idx, order) : $.map(idx, function (index) {\n        return $.inArray(index, order);\n      });\n    } else {\n      // Given a current index, want the original\n      return !Array.isArray(idx) ? columns[idx]._ColReorder_iOrigCol : $.map(idx, function (index) {\n        return columns[index]._ColReorder_iOrigCol;\n      });\n    }\n  },\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Private methods (they are of course public in JS, but recommended as private)\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n  /**\n   * Constructor logic\n   *  @method  _fnConstruct\n   *  @returns void\n   *  @private\n   */\n  \"_fnConstruct\": function () {\n    var that = this;\n    var iLen = this.s.dt.aoColumns.length;\n    var table = this.s.dt.nTable;\n    var i;\n\n    /* Columns discounted from reordering - counting left to right */\n    if (this.s.init.iFixedColumns) {\n      this.s.fixed = this.s.init.iFixedColumns;\n    }\n    if (this.s.init.iFixedColumnsLeft) {\n      this.s.fixed = this.s.init.iFixedColumnsLeft;\n    }\n\n    /* Columns discounted from reordering - counting right to left */\n    this.s.fixedRight = this.s.init.iFixedColumnsRight ? this.s.init.iFixedColumnsRight : 0;\n\n    /* Drop callback initialisation option */\n    if (this.s.init.fnReorderCallback) {\n      this.s.reorderCallback = this.s.init.fnReorderCallback;\n    }\n\n    /* Add event handlers for the drag and drop, and also mark the original column order */\n    for (i = 0; i < iLen; i++) {\n      if (i > this.s.fixed - 1 && i < iLen - this.s.fixedRight) {\n        this._fnMouseListener(i, this.s.dt.aoColumns[i].nTh);\n      }\n\n      /* Mark the original column order for later reference */\n      this.s.dt.aoColumns[i]._ColReorder_iOrigCol = i;\n    }\n\n    /* State saving */\n    this.s.dt.oApi._fnCallbackReg(this.s.dt, 'aoStateSaveParams', function (oS, oData) {\n      that._fnStateSave.call(that, oData);\n    }, \"ColReorder_State\");\n    this.s.dt.oApi._fnCallbackReg(this.s.dt, 'aoStateLoadParams', function (oS, oData) {\n      that.s.dt._colReorder.fnOrder(oData.ColReorder, true);\n    });\n\n    /* An initial column order has been specified */\n    var aiOrder = null;\n    if (this.s.init.aiOrder) {\n      aiOrder = this.s.init.aiOrder.slice();\n    }\n\n    /* State loading, overrides the column order given */\n    if (this.s.dt.oLoadedState && typeof this.s.dt.oLoadedState.ColReorder != 'undefined' && this.s.dt.oLoadedState.ColReorder.length == this.s.dt.aoColumns.length) {\n      aiOrder = this.s.dt.oLoadedState.ColReorder;\n    }\n\n    /* If we have an order to apply - do so */\n    if (aiOrder) {\n      /* We might be called during or after the DataTables initialisation. If before, then we need\n       * to wait until the draw is done, if after, then do what we need to do right away\n       */\n      if (!that.s.dt._bInitComplete) {\n        var bDone = false;\n        $(table).on('draw.dt.colReorder', function () {\n          if (!that.s.dt._bInitComplete && !bDone) {\n            bDone = true;\n            var resort = fnInvertKeyValues(aiOrder);\n            that._fnOrderColumns.call(that, resort);\n          }\n        });\n      } else {\n        var resort = fnInvertKeyValues(aiOrder);\n        that._fnOrderColumns.call(that, resort);\n      }\n    } else {\n      this._fnSetColumnIndexes();\n    }\n\n    // Destroy clean up\n    $(table).on('destroy.dt.colReorder', function () {\n      // Restore table to original order from when it was loaded\n      that.fnReset();\n      $(table).off('destroy.dt.colReorder draw.dt.colReorder');\n      $.each(that.s.dt.aoColumns, function (i, column) {\n        $(column.nTh).off('.ColReorder');\n        $(column.nTh).removeAttr('data-column-index');\n      });\n      that.s.dt._colReorder = null;\n      that.s = null;\n    });\n  },\n  /**\n   * Set the column order from an array\n   *  @method  _fnOrderColumns\n   *  @param   array a An array of integers which dictate the column order that should be applied\n   *  @returns void\n   *  @private\n   */\n  \"_fnOrderColumns\": function (a) {\n    var changed = false;\n    if (a.length != this.s.dt.aoColumns.length) {\n      this.s.dt.oInstance.oApi._fnLog(this.s.dt, 1, \"ColReorder - array reorder does not \" + \"match known number of columns. Skipping.\");\n      return;\n    }\n    for (var i = 0, iLen = a.length; i < iLen; i++) {\n      var currIndex = $.inArray(i, a);\n      if (i != currIndex) {\n        /* Reorder our switching array */\n        fnArraySwitch(a, currIndex, i);\n\n        /* Do the column reorder in the table */\n        this.s.dt.oInstance.fnColReorder(currIndex, i, true, false);\n        changed = true;\n      }\n    }\n    this._fnSetColumnIndexes();\n\n    // Has anything actually changed? If not, then nothing else to do\n    if (!changed) {\n      return;\n    }\n    $.fn.dataTable.Api(this.s.dt).rows().invalidate('data');\n\n    /* When scrolling we need to recalculate the column sizes to allow for the shift */\n    if (this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\") {\n      this.s.dt.oInstance.fnAdjustColumnSizing(false);\n    }\n\n    /* Save the state */\n    this.s.dt.oInstance.oApi._fnSaveState(this.s.dt);\n    if (this.s.reorderCallback !== null) {\n      this.s.reorderCallback.call(this);\n    }\n  },\n  /**\n   * Because we change the indexes of columns in the table, relative to their starting point\n   * we need to reorder the state columns to what they are at the starting point so we can\n   * then rearrange them again on state load!\n   *  @method  _fnStateSave\n   *  @param   object oState DataTables state\n   *  @returns string JSON encoded cookie string for DataTables\n   *  @private\n   */\n  \"_fnStateSave\": function (oState) {\n    if (this.s === null) {\n      return;\n    }\n    var i, iLen, aCopy, iOrigColumn;\n    var oSettings = this.s.dt;\n    var columns = oSettings.aoColumns;\n    oState.ColReorder = [];\n\n    /* Sorting */\n    if (oState.aaSorting) {\n      // 1.10.0-\n      for (i = 0; i < oState.aaSorting.length; i++) {\n        oState.aaSorting[i][0] = columns[oState.aaSorting[i][0]]._ColReorder_iOrigCol;\n      }\n      var aSearchCopy = $.extend(true, [], oState.aoSearchCols);\n      for (i = 0, iLen = columns.length; i < iLen; i++) {\n        iOrigColumn = columns[i]._ColReorder_iOrigCol;\n\n        /* Column filter */\n        oState.aoSearchCols[iOrigColumn] = aSearchCopy[i];\n\n        /* Visibility */\n        oState.abVisCols[iOrigColumn] = columns[i].bVisible;\n\n        /* Column reordering */\n        oState.ColReorder.push(iOrigColumn);\n      }\n    } else if (oState.order) {\n      // 1.10.1+\n      for (i = 0; i < oState.order.length; i++) {\n        oState.order[i][0] = columns[oState.order[i][0]]._ColReorder_iOrigCol;\n      }\n      var stateColumnsCopy = $.extend(true, [], oState.columns);\n      for (i = 0, iLen = columns.length; i < iLen; i++) {\n        iOrigColumn = columns[i]._ColReorder_iOrigCol;\n\n        /* Columns */\n        oState.columns[iOrigColumn] = stateColumnsCopy[i];\n\n        /* Column reordering */\n        oState.ColReorder.push(iOrigColumn);\n      }\n    }\n  },\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Mouse drop and drag\n   */\n\n  /**\n   * Add a mouse down listener to a particluar TH element\n   *  @method  _fnMouseListener\n   *  @param   int i Column index\n   *  @param   element nTh TH element clicked on\n   *  @returns void\n   *  @private\n   */\n  \"_fnMouseListener\": function (i, nTh) {\n    var that = this;\n    $(nTh).on('mousedown.ColReorder', function (e) {\n      if (that.s.enable && e.which === 1) {\n        that._fnMouseDown.call(that, e, nTh);\n      }\n    }).on('touchstart.ColReorder', function (e) {\n      if (that.s.enable) {\n        that._fnMouseDown.call(that, e, nTh);\n      }\n    });\n  },\n  /**\n   * Mouse down on a TH element in the table header\n   *  @method  _fnMouseDown\n   *  @param   event e Mouse event\n   *  @param   element nTh TH element to be dragged\n   *  @returns void\n   *  @private\n   */\n  \"_fnMouseDown\": function (e, nTh) {\n    var that = this;\n\n    /* Store information about the mouse position */\n    var target = $(e.target).closest('th, td');\n    var offset = target.offset();\n    var idx = parseInt($(nTh).attr('data-column-index'), 10);\n    if (idx === undefined) {\n      return;\n    }\n    this.s.mouse.startX = this._fnCursorPosition(e, 'pageX');\n    this.s.mouse.startY = this._fnCursorPosition(e, 'pageY');\n    this.s.mouse.offsetX = this._fnCursorPosition(e, 'pageX') - offset.left;\n    this.s.mouse.offsetY = this._fnCursorPosition(e, 'pageY') - offset.top;\n    this.s.mouse.target = this.s.dt.aoColumns[idx].nTh; //target[0];\n    this.s.mouse.targetIndex = idx;\n    this.s.mouse.fromIndex = idx;\n    this._fnRegions();\n\n    /* Add event handlers to the document */\n    $(document).on('mousemove.ColReorder touchmove.ColReorder', function (e) {\n      that._fnMouseMove.call(that, e);\n    }).on('mouseup.ColReorder touchend.ColReorder', function (e) {\n      that._fnMouseUp.call(that, e);\n    });\n  },\n  /**\n   * Deal with a mouse move event while dragging a node\n   *  @method  _fnMouseMove\n   *  @param   event e Mouse event\n   *  @returns void\n   *  @private\n   */\n  \"_fnMouseMove\": function (e) {\n    var that = this;\n    if (this.dom.drag === null) {\n      /* Only create the drag element if the mouse has moved a specific distance from the start\n       * point - this allows the user to make small mouse movements when sorting and not have a\n       * possibly confusing drag element showing up\n       */\n      if (Math.pow(Math.pow(this._fnCursorPosition(e, 'pageX') - this.s.mouse.startX, 2) + Math.pow(this._fnCursorPosition(e, 'pageY') - this.s.mouse.startY, 2), 0.5) < 5) {\n        return;\n      }\n      this._fnCreateDragNode();\n    }\n\n    /* Position the element - we respect where in the element the click occured */\n    this.dom.drag.css({\n      left: this._fnCursorPosition(e, 'pageX') - this.s.mouse.offsetX,\n      top: this._fnCursorPosition(e, 'pageY') - this.s.mouse.offsetY\n    });\n\n    /* Based on the current mouse position, calculate where the insert should go */\n    var target;\n    var lastToIndex = this.s.mouse.toIndex;\n    var cursorXPosiotion = this._fnCursorPosition(e, 'pageX');\n    var targetsPrev = function (i) {\n      while (i >= 0) {\n        i--;\n        if (i <= 0) {\n          return null;\n        }\n        if (that.s.aoTargets[i + 1].x !== that.s.aoTargets[i].x) {\n          return that.s.aoTargets[i];\n        }\n      }\n    };\n    var firstNotHidden = function () {\n      for (var i = 0; i < that.s.aoTargets.length - 1; i++) {\n        if (that.s.aoTargets[i].x !== that.s.aoTargets[i + 1].x) {\n          return that.s.aoTargets[i];\n        }\n      }\n    };\n    var lastNotHidden = function () {\n      for (var i = that.s.aoTargets.length - 1; i > 0; i--) {\n        if (that.s.aoTargets[i].x !== that.s.aoTargets[i - 1].x) {\n          return that.s.aoTargets[i];\n        }\n      }\n    };\n    for (var i = 1; i < this.s.aoTargets.length; i++) {\n      var prevTarget = targetsPrev(i);\n      if (!prevTarget) {\n        prevTarget = firstNotHidden();\n      }\n      var prevTargetMiddle = prevTarget.x + (this.s.aoTargets[i].x - prevTarget.x) / 2;\n      if (this._fnIsLtr()) {\n        if (cursorXPosiotion < prevTargetMiddle) {\n          target = prevTarget;\n          break;\n        }\n      } else {\n        if (cursorXPosiotion > prevTargetMiddle) {\n          target = prevTarget;\n          break;\n        }\n      }\n    }\n    if (target) {\n      this.dom.pointer.css('left', target.x);\n      this.s.mouse.toIndex = target.to;\n    } else {\n      // The insert element wasn't positioned in the array (less than\n      // operator), so we put it at the end\n      this.dom.pointer.css('left', lastNotHidden().x);\n      this.s.mouse.toIndex = lastNotHidden().to;\n    }\n\n    // Perform reordering if realtime updating is on and the column has moved\n    if (this.s.init.bRealtime && lastToIndex !== this.s.mouse.toIndex) {\n      this.s.dt.oInstance.fnColReorder(this.s.mouse.fromIndex, this.s.mouse.toIndex);\n      this.s.mouse.fromIndex = this.s.mouse.toIndex;\n\n      // Not great for performance, but required to keep everything in alignment\n      if (this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\") {\n        this.s.dt.oInstance.fnAdjustColumnSizing(false);\n      }\n      this._fnRegions();\n    }\n  },\n  /**\n   * Finish off the mouse drag and insert the column where needed\n   *  @method  _fnMouseUp\n   *  @param   event e Mouse event\n   *  @returns void\n   *  @private\n   */\n  \"_fnMouseUp\": function (e) {\n    var that = this;\n    $(document).off('.ColReorder');\n    if (this.dom.drag !== null) {\n      /* Remove the guide elements */\n      this.dom.drag.remove();\n      this.dom.pointer.remove();\n      this.dom.drag = null;\n      this.dom.pointer = null;\n\n      /* Actually do the reorder */\n      this.s.dt.oInstance.fnColReorder(this.s.mouse.fromIndex, this.s.mouse.toIndex, true);\n      this._fnSetColumnIndexes();\n\n      /* When scrolling we need to recalculate the column sizes to allow for the shift */\n      if (this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\") {\n        this.s.dt.oInstance.fnAdjustColumnSizing(false);\n      }\n\n      /* Save the state */\n      this.s.dt.oInstance.oApi._fnSaveState(this.s.dt);\n      if (this.s.reorderCallback !== null) {\n        this.s.reorderCallback.call(this);\n      }\n    }\n  },\n  /**\n   * Calculate a cached array with the points of the column inserts, and the\n   * 'to' points\n   *  @method  _fnRegions\n   *  @returns void\n   *  @private\n   */\n  \"_fnRegions\": function () {\n    var aoColumns = this.s.dt.aoColumns;\n    var isLTR = this._fnIsLtr();\n    this.s.aoTargets.splice(0, this.s.aoTargets.length);\n    var lastBound = $(this.s.dt.nTable).offset().left;\n    var aoColumnBounds = [];\n    $.each(aoColumns, function (i, column) {\n      if (column.bVisible && column.nTh.style.display !== 'none') {\n        var nth = $(column.nTh);\n        var bound = nth.offset().left;\n        if (isLTR) {\n          bound += nth.outerWidth();\n        }\n        aoColumnBounds.push({\n          index: i,\n          bound: bound\n        });\n        lastBound = bound;\n      } else {\n        aoColumnBounds.push({\n          index: i,\n          bound: lastBound\n        });\n      }\n    });\n    var firstColumn = aoColumnBounds[0];\n    var firstColumnWidth = $(aoColumns[firstColumn.index].nTh).outerWidth();\n    this.s.aoTargets.push({\n      to: 0,\n      x: firstColumn.bound - firstColumnWidth\n    });\n    for (var i = 0; i < aoColumnBounds.length; i++) {\n      var columnBound = aoColumnBounds[i];\n      var iToPoint = columnBound.index;\n\n      /* For the column / header in question, we want it's position to remain the same if the\n      * position is just to it's immediate left or right, so we only increment the counter for\n      * other columns\n      */\n      if (columnBound.index < this.s.mouse.fromIndex) {\n        iToPoint++;\n      }\n      this.s.aoTargets.push({\n        to: iToPoint,\n        x: columnBound.bound\n      });\n    }\n\n    /* Disallow columns for being reordered by drag and drop, counting right to left */\n    if (this.s.fixedRight !== 0) {\n      this.s.aoTargets.splice(this.s.aoTargets.length - this.s.fixedRight);\n    }\n\n    /* Disallow columns for being reordered by drag and drop, counting left to right */\n    if (this.s.fixed !== 0) {\n      this.s.aoTargets.splice(0, this.s.fixed);\n    }\n  },\n  /**\n   * Copy the TH element that is being drags so the user has the idea that they are actually\n   * moving it around the page.\n   *  @method  _fnCreateDragNode\n   *  @returns void\n   *  @private\n   */\n  \"_fnCreateDragNode\": function () {\n    var scrolling = this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\";\n    var origCell = this.s.dt.aoColumns[this.s.mouse.targetIndex].nTh;\n    var origTr = origCell.parentNode;\n    var origThead = origTr.parentNode;\n    var origTable = origThead.parentNode;\n    var cloneCell = $(origCell).clone();\n\n    // This is a slightly odd combination of jQuery and DOM, but it is the\n    // fastest and least resource intensive way I could think of cloning\n    // the table with just a single header cell in it.\n    this.dom.drag = $(origTable.cloneNode(false)).addClass('DTCR_clonedTable').append($(origThead.cloneNode(false)).append($(origTr.cloneNode(false)).append(cloneCell[0]))).css({\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: $(origCell).outerWidth(),\n      height: $(origCell).outerHeight()\n    }).appendTo('body');\n    this.dom.pointer = $('<div></div>').addClass('DTCR_pointer').css({\n      position: 'absolute',\n      top: scrolling ? $($(this.s.dt.nScrollBody).parent()).offset().top : $(this.s.dt.nTable).offset().top,\n      height: scrolling ? $($(this.s.dt.nScrollBody).parent()).height() : $(this.s.dt.nTable).height()\n    }).appendTo('body');\n  },\n  /**\n   * Add a data attribute to the column headers, so we know the index of\n   * the row to be reordered. This allows fast detection of the index, and\n   * for this plug-in to work with FixedHeader which clones the nodes.\n   *  @private\n   */\n  \"_fnSetColumnIndexes\": function () {\n    $.each(this.s.dt.aoColumns, function (i, column) {\n      $(column.nTh).attr('data-column-index', i);\n    });\n  },\n  /**\n   * Get cursor position regardless of mouse or touch input\n   * @param  {Event}  e    jQuery Event\n   * @param  {string} prop Property to get\n   * @return {number}      Value\n   */\n  _fnCursorPosition: function (e, prop) {\n    if (e.type.indexOf('touch') !== -1) {\n      return e.originalEvent.touches[0][prop];\n    }\n    return e[prop];\n  },\n  _fnIsLtr: function () {\n    return $(this.s.dt.nTable).css('direction') !== \"rtl\";\n  }\n});\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Static parameters\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * ColReorder default settings for initialisation\n *  @namespace\n *  @static\n */\nColReorder.defaults = {\n  /**\n   * Predefined ordering for the columns that will be applied automatically\n   * on initialisation. If not specified then the order that the columns are\n   * found to be in the HTML is the order used.\n   *  @type array\n   *  @default null\n   *  @static\n   */\n  aiOrder: null,\n  /**\n   * ColReorder enable on initialisation\n   *  @type boolean\n   *  @default true\n   *  @static\n   */\n  bEnable: true,\n  /**\n   * Redraw the table's column ordering as the end user draws the column\n   * (`true`) or wait until the mouse is released (`false` - default). Note\n   * that this will perform a redraw on each reordering, which involves an\n   * Ajax request each time if you are using server-side processing in\n   * DataTables.\n   *  @type boolean\n   *  @default false\n   *  @static\n   */\n  bRealtime: true,\n  /**\n   * Indicate how many columns should be fixed in position (counting from the\n   * left). This will typically be 1 if used, but can be as high as you like.\n   *  @type int\n   *  @default 0\n   *  @static\n   */\n  iFixedColumnsLeft: 0,\n  /**\n   * As `iFixedColumnsRight` but counting from the right.\n   *  @type int\n   *  @default 0\n   *  @static\n   */\n  iFixedColumnsRight: 0,\n  /**\n   * Callback function that is fired when columns are reordered. The `column-\n   * reorder` event is preferred over this callback\n   *  @type function():void\n   *  @default null\n   *  @static\n   */\n  fnReorderCallback: null\n};\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Constants\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * ColReorder version\n *  @constant  version\n *  @type      String\n *  @default   As code\n */\nColReorder.version = \"1.6.2\";\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables interfaces\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n// Expose\n$.fn.dataTable.ColReorder = ColReorder;\n$.fn.DataTable.ColReorder = ColReorder;\n\n// Register a new feature with DataTables\nif (typeof $.fn.dataTable == \"function\" && typeof $.fn.dataTableExt.fnVersionCheck == \"function\" && $.fn.dataTableExt.fnVersionCheck('1.10.8')) {\n  $.fn.dataTableExt.aoFeatures.push({\n    \"fnInit\": function (settings) {\n      var table = settings.oInstance;\n      if (!settings._colReorder) {\n        var dtInit = settings.oInit;\n        var opts = dtInit.colReorder || dtInit.oColReorder || {};\n        new ColReorder(settings, opts);\n      } else {\n        table.oApi._fnLog(settings, 1, \"ColReorder attempted to initialise twice. Ignoring second\");\n      }\n      return null; /* No node for DataTables to insert */\n    },\n\n    \"cFeature\": \"R\",\n    \"sFeature\": \"ColReorder\"\n  });\n} else {\n  alert(\"Warning: ColReorder requires DataTables 1.10.8 or greater - www.datatables.net/download\");\n}\n\n// Attach a listener to the document which listens for DataTables initialisation\n// events so we can automatically initialise\n$(document).on('preInit.dt.colReorder', function (e, settings) {\n  if (e.namespace !== 'dt') {\n    return;\n  }\n  var init = settings.oInit.colReorder;\n  var defaults = DataTable.defaults.colReorder;\n  if (init || defaults) {\n    var opts = $.extend({}, init, defaults);\n    if (init !== false) {\n      new ColReorder(settings, opts);\n    }\n  }\n});\n\n// API augmentation\n$.fn.dataTable.Api.register('colReorder.reset()', function () {\n  return this.iterator('table', function (ctx) {\n    ctx._colReorder.fnReset();\n  });\n});\n$.fn.dataTable.Api.register('colReorder.order()', function (set, original) {\n  if (set) {\n    return this.iterator('table', function (ctx) {\n      ctx._colReorder.fnOrder(set, original);\n    });\n  }\n  return this.context.length ? this.context[0]._colReorder.fnOrder() : null;\n});\n$.fn.dataTable.Api.register('colReorder.transpose()', function (idx, dir) {\n  return this.context.length && this.context[0]._colReorder ? this.context[0]._colReorder.fnTranspose(idx, dir) : idx;\n});\n$.fn.dataTable.Api.register('colReorder.move()', function (from, to, drop, invalidateRows) {\n  if (this.context.length) {\n    this.context[0]._colReorder.s.dt.oInstance.fnColReorder(from, to, drop, invalidateRows);\n    this.context[0]._colReorder._fnSetColumnIndexes();\n  }\n  return this;\n});\n$.fn.dataTable.Api.register('colReorder.enable()', function (flag) {\n  return this.iterator('table', function (ctx) {\n    if (ctx._colReorder) {\n      ctx._colReorder.fnEnable(flag);\n    }\n  });\n});\n$.fn.dataTable.Api.register('colReorder.disable()', function () {\n  return this.iterator('table', function (ctx) {\n    if (ctx._colReorder) {\n      ctx._colReorder.fnDisable();\n    }\n  });\n});\nexport default DataTable;","map":{"version":3,"names":["$","DataTable","fnInvertKeyValues","aIn","aRet","i","iLen","length","fnArraySwitch","aArray","iFrom","iTo","mStore","splice","fnDomSwitch","nParent","anTags","childNodes","nodeType","push","nStore","insertBefore","appendChild","fn","dataTableExt","oApi","fnColReorder","oSettings","drop","invalidateRows","j","jLen","jen","iCols","aoColumns","nTrs","oCol","attrMap","obj","prop","mapping","a","split","num","shift","isNaN","join","_fnLog","aiMapping","aiInvertMapping","aaSorting","aaSortingFixed","aDataSort","idx","each","aLastSort","val","src","mData","isPlainObject","bVisible","iVisibleIndex","_fnColumnIndexToVisible","iInsertBeforeIndex","nTHead","getElementsByTagName","nTFoot","aoData","nTr","_fnColumnOptions","aoPreSearchCols","data","cells","anCells","_DT_CellIndex","column","Array","isArray","_aData","aoHeader","aoFooter","undefined","dataTable","Api","rows","invalidate","nTh","off","_fnSortAttachListener","oInstance","trigger","from","to","ColReorder","dt","opts","settings","_colReorder","camelToHungarian","defaults","s","extend","dom","enable","init","bEnable","_fnConstruct","prototype","fnEnable","flag","fnDisable","fnReset","_fnOrderColumns","fnOrder","fnGetCurrentOrder","set","original","ien","columns","_ColReorder_iOrigCol","order","inArray","fnTranspose","dir","map","index","that","table","nTable","iFixedColumns","fixed","iFixedColumnsLeft","fixedRight","iFixedColumnsRight","fnReorderCallback","reorderCallback","_fnMouseListener","_fnCallbackReg","oS","oData","_fnStateSave","call","aiOrder","slice","oLoadedState","_bInitComplete","bDone","on","resort","_fnSetColumnIndexes","removeAttr","changed","currIndex","oScroll","sX","sY","fnAdjustColumnSizing","_fnSaveState","oState","aCopy","iOrigColumn","aSearchCopy","aoSearchCols","abVisCols","stateColumnsCopy","e","which","_fnMouseDown","target","closest","offset","parseInt","attr","mouse","startX","_fnCursorPosition","startY","offsetX","left","offsetY","top","targetIndex","fromIndex","_fnRegions","document","_fnMouseMove","_fnMouseUp","drag","Math","pow","_fnCreateDragNode","css","lastToIndex","toIndex","cursorXPosiotion","targetsPrev","aoTargets","x","firstNotHidden","lastNotHidden","prevTarget","prevTargetMiddle","_fnIsLtr","pointer","bRealtime","remove","isLTR","lastBound","aoColumnBounds","style","display","nth","bound","outerWidth","firstColumn","firstColumnWidth","columnBound","iToPoint","scrolling","origCell","origTr","parentNode","origThead","origTable","cloneCell","clone","cloneNode","addClass","append","position","width","height","outerHeight","appendTo","nScrollBody","parent","type","indexOf","originalEvent","touches","version","fnVersionCheck","aoFeatures","fnInit","dtInit","oInit","colReorder","oColReorder","alert","namespace","register","iterator","ctx","context"],"sources":["/Users/phanikrovvidi/Library/CloudStorage/Box-Box/Phani.Krovvidi/Personal/programming/coldsoft/client/node_modules/datatables.net-colreorder/js/dataTables.colReorder.mjs"],"sourcesContent":["/*! ColReorder 1.6.2\n * © SpryMedia Ltd - datatables.net/license\n */\n\nimport $ from 'jquery';\nimport DataTable from 'datatables.net';\n\n\n/**\n * @summary     ColReorder\n * @description Provide the ability to reorder columns in a DataTable\n * @version     1.6.2\n * @author      SpryMedia Ltd\n * @contact     datatables.net\n * @copyright   SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n\n/**\n * Switch the key value pairing of an index array to be value key (i.e. the old value is now the\n * key). For example consider [ 2, 0, 1 ] this would be returned as [ 1, 2, 0 ].\n *  @method  fnInvertKeyValues\n *  @param   array aIn Array to switch around\n *  @returns array\n */\nfunction fnInvertKeyValues( aIn )\n{\n\tvar aRet=[];\n\tfor ( var i=0, iLen=aIn.length ; i<iLen ; i++ )\n\t{\n\t\taRet[ aIn[i] ] = i;\n\t}\n\treturn aRet;\n}\n\n\n/**\n * Modify an array by switching the position of two elements\n *  @method  fnArraySwitch\n *  @param   array aArray Array to consider, will be modified by reference (i.e. no return)\n *  @param   int iFrom From point\n *  @param   int iTo Insert point\n *  @returns void\n */\nfunction fnArraySwitch( aArray, iFrom, iTo )\n{\n\tvar mStore = aArray.splice( iFrom, 1 )[0];\n\taArray.splice( iTo, 0, mStore );\n}\n\n\n/**\n * Switch the positions of nodes in a parent node (note this is specifically designed for\n * table rows). Note this function considers all element nodes under the parent!\n *  @method  fnDomSwitch\n *  @param   string sTag Tag to consider\n *  @param   int iFrom Element to move\n *  @param   int Point to element the element to (before this point), can be null for append\n *  @returns void\n */\nfunction fnDomSwitch( nParent, iFrom, iTo )\n{\n\tvar anTags = [];\n\tfor ( var i=0, iLen=nParent.childNodes.length ; i<iLen ; i++ )\n\t{\n\t\tif ( nParent.childNodes[i].nodeType == 1 )\n\t\t{\n\t\t\tanTags.push( nParent.childNodes[i] );\n\t\t}\n\t}\n\tvar nStore = anTags[ iFrom ];\n\n\tif ( iTo !== null )\n\t{\n\t\tnParent.insertBefore( nStore, anTags[iTo] );\n\t}\n\telse\n\t{\n\t\tnParent.appendChild( nStore );\n\t}\n}\n\n\n/**\n * Plug-in for DataTables which will reorder the internal column structure by taking the column\n * from one position (iFrom) and insert it into a given point (iTo).\n *  @method  $.fn.dataTableExt.oApi.fnColReorder\n *  @param   object oSettings DataTables settings object - automatically added by DataTables!\n *  @param   int iFrom Take the column to be repositioned from this point\n *  @param   int iTo and insert it into this point\n *  @param   bool drop Indicate if the reorder is the final one (i.e. a drop)\n *    not a live reorder\n *  @param   bool invalidateRows speeds up processing if false passed\n *  @returns void\n */\n$.fn.dataTableExt.oApi.fnColReorder = function ( oSettings, iFrom, iTo, drop, invalidateRows )\n{\n\tvar i, iLen, j, jLen, jen, iCols=oSettings.aoColumns.length, nTrs, oCol;\n\tvar attrMap = function ( obj, prop, mapping ) {\n\t\tif ( ! obj[ prop ] || typeof obj[ prop ] === 'function' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar a = obj[ prop ].split('.');\n\t\tvar num = a.shift();\n\n\t\tif ( isNaN( num*1 ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tobj[ prop ] = mapping[ num*1 ]+'.'+a.join('.');\n\t};\n\n\t/* Sanity check in the input */\n\tif ( iFrom == iTo )\n\t{\n\t\t/* Pointless reorder */\n\t\treturn;\n\t}\n\n\tif ( iFrom < 0 || iFrom >= iCols )\n\t{\n\t\tthis.oApi._fnLog( oSettings, 1, \"ColReorder 'from' index is out of bounds: \"+iFrom );\n\t\treturn;\n\t}\n\n\tif ( iTo < 0 || iTo >= iCols )\n\t{\n\t\tthis.oApi._fnLog( oSettings, 1, \"ColReorder 'to' index is out of bounds: \"+iTo );\n\t\treturn;\n\t}\n\n\t/*\n\t * Calculate the new column array index, so we have a mapping between the old and new\n\t */\n\tvar aiMapping = [];\n\tfor ( i=0, iLen=iCols ; i<iLen ; i++ )\n\t{\n\t\taiMapping[i] = i;\n\t}\n\tfnArraySwitch( aiMapping, iFrom, iTo );\n\tvar aiInvertMapping = fnInvertKeyValues( aiMapping );\n\n\n\t/*\n\t * Convert all internal indexing to the new column order indexes\n\t */\n\t/* Sorting */\n\tfor ( i=0, iLen=oSettings.aaSorting.length ; i<iLen ; i++ )\n\t{\n\t\toSettings.aaSorting[i][0] = aiInvertMapping[ oSettings.aaSorting[i][0] ];\n\t}\n\n\t/* Fixed sorting */\n\tif ( oSettings.aaSortingFixed !== null )\n\t{\n\t\tfor ( i=0, iLen=oSettings.aaSortingFixed.length ; i<iLen ; i++ )\n\t\t{\n\t\t\toSettings.aaSortingFixed[i][0] = aiInvertMapping[ oSettings.aaSortingFixed[i][0] ];\n\t\t}\n\t}\n\n\t/* Data column sorting (the column which the sort for a given column should take place on) */\n\tfor ( i=0, iLen=iCols ; i<iLen ; i++ )\n\t{\n\t\toCol = oSettings.aoColumns[i];\n\t\tfor ( j=0, jLen=oCol.aDataSort.length ; j<jLen ; j++ )\n\t\t{\n\t\t\toCol.aDataSort[j] = aiInvertMapping[ oCol.aDataSort[j] ];\n\t\t}\n\n\t\t// Update the column indexes\n\t\toCol.idx = aiInvertMapping[ oCol.idx ];\n\t}\n\n\t// Update 1.10 optimised sort class removal variable\n\t$.each( oSettings.aLastSort, function (i, val) {\n\t\toSettings.aLastSort[i].src = aiInvertMapping[ val.src ];\n\t} );\n\n\t/* Update the Get and Set functions for each column */\n\tfor ( i=0, iLen=iCols ; i<iLen ; i++ )\n\t{\n\t\toCol = oSettings.aoColumns[i];\n\n\t\tif ( typeof oCol.mData == 'number' ) {\n\t\t\toCol.mData = aiInvertMapping[ oCol.mData ];\n\t\t}\n\t\telse if ( $.isPlainObject( oCol.mData ) ) {\n\t\t\t// HTML5 data sourced\n\t\t\tattrMap( oCol.mData, '_',      aiInvertMapping );\n\t\t\tattrMap( oCol.mData, 'filter', aiInvertMapping );\n\t\t\tattrMap( oCol.mData, 'sort',   aiInvertMapping );\n\t\t\tattrMap( oCol.mData, 'type',   aiInvertMapping );\n\t\t}\n\t}\n\n\t/*\n\t * Move the DOM elements\n\t */\n\tif ( oSettings.aoColumns[iFrom].bVisible )\n\t{\n\t\t/* Calculate the current visible index and the point to insert the node before. The insert\n\t\t * before needs to take into account that there might not be an element to insert before,\n\t\t * in which case it will be null, and an appendChild should be used\n\t\t */\n\t\tvar iVisibleIndex = this.oApi._fnColumnIndexToVisible( oSettings, iFrom );\n\t\tvar iInsertBeforeIndex = null;\n\n\t\ti = iTo < iFrom ? iTo : iTo + 1;\n\t\twhile ( iInsertBeforeIndex === null && i < iCols )\n\t\t{\n\t\t\tiInsertBeforeIndex = this.oApi._fnColumnIndexToVisible( oSettings, i );\n\t\t\ti++;\n\t\t}\n\n\t\t/* Header */\n\t\tnTrs = oSettings.nTHead.getElementsByTagName('tr');\n\t\tfor ( i=0, iLen=nTrs.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tfnDomSwitch( nTrs[i], iVisibleIndex, iInsertBeforeIndex );\n\t\t}\n\n\t\t/* Footer */\n\t\tif ( oSettings.nTFoot !== null )\n\t\t{\n\t\t\tnTrs = oSettings.nTFoot.getElementsByTagName('tr');\n\t\t\tfor ( i=0, iLen=nTrs.length ; i<iLen ; i++ )\n\t\t\t{\n\t\t\t\tfnDomSwitch( nTrs[i], iVisibleIndex, iInsertBeforeIndex );\n\t\t\t}\n\t\t}\n\n\t\t/* Body */\n\t\tfor ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tif ( oSettings.aoData[i].nTr !== null )\n\t\t\t{\n\t\t\t\tfnDomSwitch( oSettings.aoData[i].nTr, iVisibleIndex, iInsertBeforeIndex );\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Move the internal array elements\n\t */\n\t/* Columns */\n\tfnArraySwitch( oSettings.aoColumns, iFrom, iTo );\n\n\t// regenerate the get / set functions\n\tfor ( i=0, iLen=iCols ; i<iLen ; i++ ) {\n\t\toSettings.oApi._fnColumnOptions( oSettings, i, {} );\n\t}\n\n\t/* Search columns */\n\tfnArraySwitch( oSettings.aoPreSearchCols, iFrom, iTo );\n\n\t/* Array array - internal data anodes cache */\n\tfor ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )\n\t{\n\t\tvar data = oSettings.aoData[i];\n\t\tvar cells = data.anCells;\n\n\t\tif ( cells ) {\n\t\t\tfnArraySwitch( cells, iFrom, iTo );\n\n\t\t\t// Longer term, should this be moved into the DataTables' invalidate\n\t\t\t// methods?\n\t\t\tfor ( j=0, jen=cells.length ; j<jen ; j++ ) {\n\t\t\t\tif ( cells[j] && cells[j]._DT_CellIndex ) {\n\t\t\t\t\tcells[j]._DT_CellIndex.column = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Swap around array sourced data (object based is left as is)\n\t\tif ( Array.isArray( data._aData ) ) {\n\t\t\tfnArraySwitch( data._aData, iFrom, iTo );\n\t\t}\n\t}\n\n\t/* Reposition the header elements in the header layout array */\n\tfor ( i=0, iLen=oSettings.aoHeader.length ; i<iLen ; i++ )\n\t{\n\t\tfnArraySwitch( oSettings.aoHeader[i], iFrom, iTo );\n\t}\n\n\tif ( oSettings.aoFooter !== null )\n\t{\n\t\tfor ( i=0, iLen=oSettings.aoFooter.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tfnArraySwitch( oSettings.aoFooter[i], iFrom, iTo );\n\t\t}\n\t}\n\n\tif ( invalidateRows || invalidateRows === undefined )\n\t{\n\t\t// Always read from the data object rather than reading back from the DOM\n\t\t// since it could have been changed by a renderer\n\t\t$.fn.dataTable.Api( oSettings ).rows().invalidate('data');\n\t}\n\n\t/*\n\t * Update DataTables' event handlers\n\t */\n\n\t/* Sort listener */\n\tfor ( i=0, iLen=iCols ; i<iLen ; i++ )\n\t{\n\t\t$(oSettings.aoColumns[i].nTh).off('.DT');\n\t\tthis.oApi._fnSortAttachListener( oSettings, oSettings.aoColumns[i].nTh, i );\n\t}\n\n\n\t/* Fire an event so other plug-ins can update */\n\t$(oSettings.oInstance).trigger( 'column-reorder.dt', [ oSettings, {\n\t\tfrom: iFrom,\n\t\tto: iTo,\n\t\tmapping: aiInvertMapping,\n\t\tdrop: drop,\n\n\t\t// Old style parameters for compatibility\n\t\tiFrom: iFrom,\n\t\tiTo: iTo,\n\t\taiInvertMapping: aiInvertMapping\n\t} ] );\n};\n\n/**\n * ColReorder provides column visibility control for DataTables\n * @class ColReorder\n * @constructor\n * @param {object} dt DataTables settings object\n * @param {object} opts ColReorder options\n */\nvar ColReorder = function( dt, opts )\n{\n\tvar settings = new $.fn.dataTable.Api( dt ).settings()[0];\n\n\t// Ensure that we can't initialise on the same table twice\n\tif ( settings._colReorder ) {\n\t\treturn settings._colReorder;\n\t}\n\n\t// Allow the options to be a boolean for defaults\n\tif ( opts === true ) {\n\t\topts = {};\n\t}\n\n\t// Convert from camelCase to Hungarian, just as DataTables does\n\tvar camelToHungarian = $.fn.dataTable.camelToHungarian;\n\tif ( camelToHungarian ) {\n\t\tcamelToHungarian( ColReorder.defaults, ColReorder.defaults, true );\n\t\tcamelToHungarian( ColReorder.defaults, opts || {} );\n\t}\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public class variables\n\t * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\t/**\n\t * @namespace Settings object which contains customisable information for ColReorder instance\n\t */\n\tthis.s = {\n\t\t/**\n\t\t * DataTables settings object\n\t\t *  @property dt\n\t\t *  @type     Object\n\t\t *  @default  null\n\t\t */\n\t\t\"dt\": null,\n\n\t\t/**\n\t\t * Enable flag\n\t\t *  @property dt\n\t\t *  @type     Object\n\t\t *  @default  null\n\t\t */\n\t\t\"enable\": null,\n\n\t\t/**\n\t\t * Initialisation object used for this instance\n\t\t *  @property init\n\t\t *  @type     object\n\t\t *  @default  {}\n\t\t */\n\t\t\"init\": $.extend( true, {}, ColReorder.defaults, opts ),\n\n\t\t/**\n\t\t * Number of columns to fix (not allow to be reordered)\n\t\t *  @property fixed\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t */\n\t\t\"fixed\": 0,\n\n\t\t/**\n\t\t * Number of columns to fix counting from right (not allow to be reordered)\n\t\t *  @property fixedRight\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t */\n\t\t\"fixedRight\": 0,\n\n\t\t/**\n\t\t * Callback function for once the reorder has been done\n\t\t *  @property reorderCallback\n\t\t *  @type     function\n\t\t *  @default  null\n\t\t */\n\t\t\"reorderCallback\": null,\n\n\t\t/**\n\t\t * @namespace Information used for the mouse drag\n\t\t */\n\t\t\"mouse\": {\n\t\t\t\"startX\": -1,\n\t\t\t\"startY\": -1,\n\t\t\t\"offsetX\": -1,\n\t\t\t\"offsetY\": -1,\n\t\t\t\"target\": -1,\n\t\t\t\"targetIndex\": -1,\n\t\t\t\"fromIndex\": -1\n\t\t},\n\n\t\t/**\n\t\t * Information which is used for positioning the insert cusor and knowing where to do the\n\t\t * insert. Array of objects with the properties:\n\t\t *   x: x-axis position\n\t\t *   to: insert point\n\t\t *  @property aoTargets\n\t\t *  @type     array\n\t\t *  @default  []\n\t\t */\n\t\t\"aoTargets\": []\n\t};\n\n\n\t/**\n\t * @namespace Common and useful DOM elements for the class instance\n\t */\n\tthis.dom = {\n\t\t/**\n\t\t * Dragging element (the one the mouse is moving)\n\t\t *  @property drag\n\t\t *  @type     element\n\t\t *  @default  null\n\t\t */\n\t\t\"drag\": null,\n\n\t\t/**\n\t\t * The insert cursor\n\t\t *  @property pointer\n\t\t *  @type     element\n\t\t *  @default  null\n\t\t */\n\t\t\"pointer\": null\n\t};\n\n\t/* Constructor logic */\n\tthis.s.enable = this.s.init.bEnable;\n\tthis.s.dt = settings;\n\tthis.s.dt._colReorder = this;\n\tthis._fnConstruct();\n\n\treturn this;\n};\n\n\n\n$.extend( ColReorder.prototype, {\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods\n\t * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\t/**\n\t * Enable / disable end user interaction\n\t */\n\tfnEnable: function ( flag )\n\t{\n\t\tif ( flag === false ) {\n\t\t\treturn this.fnDisable();\n\t\t}\n\n\t\tthis.s.enable = true;\n\t},\n\n\t/**\n\t * Disable end user interaction\n\t */\n\tfnDisable: function ()\n\t{\n\t\tthis.s.enable = false;\n\t},\n\n\t/**\n\t * Reset the column ordering to the original ordering that was detected on\n\t * start up.\n\t *  @return {this} Returns `this` for chaining.\n\t *\n\t *  @example\n\t *    // DataTables initialisation with ColReorder\n\t *    var table = $('#example').dataTable( {\n\t *        \"sDom\": 'Rlfrtip'\n\t *    } );\n\t *\n\t *    // Add click event to a button to reset the ordering\n\t *    $('#resetOrdering').click( function (e) {\n\t *        e.preventDefault();\n\t *        $.fn.dataTable.ColReorder( table ).fnReset();\n\t *    } );\n\t */\n\t\"fnReset\": function ()\n\t{\n\t\tthis._fnOrderColumns( this.fnOrder() );\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * `Deprecated` - Get the current order of the columns, as an array.\n\t *  @return {array} Array of column identifiers\n\t *  @deprecated `fnOrder` should be used in preference to this method.\n\t *      `fnOrder` acts as a getter/setter.\n\t */\n\t\"fnGetCurrentOrder\": function ()\n\t{\n\t\treturn this.fnOrder();\n\t},\n\n\t/**\n\t * Get the current order of the columns, as an array. Note that the values\n\t * given in the array are unique identifiers for each column. Currently\n\t * these are the original ordering of the columns that was detected on\n\t * start up, but this could potentially change in future.\n\t *  @return {array} Array of column identifiers\n\t *\n\t *  @example\n\t *    // Get column ordering for the table\n\t *    var order = $.fn.dataTable.ColReorder( dataTable ).fnOrder();\n\t *//**\n\t * Set the order of the columns, from the positions identified in the\n\t * ordering array given. Note that ColReorder takes a brute force approach\n\t * to reordering, so it is possible multiple reordering events will occur\n\t * before the final order is settled upon.\n\t *  @param {array} [set] Array of column identifiers in the new order. Note\n\t *    that every column must be included, uniquely, in this array.\n\t *  @return {this} Returns `this` for chaining.\n\t *\n\t *  @example\n\t *    // Swap the first and second columns\n\t *    $.fn.dataTable.ColReorder( dataTable ).fnOrder( [1, 0, 2, 3, 4] );\n\t *\n\t *  @example\n\t *    // Move the first column to the end for the table `#example`\n\t *    var curr = $.fn.dataTable.ColReorder( '#example' ).fnOrder();\n\t *    var first = curr.shift();\n\t *    curr.push( first );\n\t *    $.fn.dataTable.ColReorder( '#example' ).fnOrder( curr );\n\t *\n\t *  @example\n\t *    // Reverse the table's order\n\t *    $.fn.dataTable.ColReorder( '#example' ).fnOrder(\n\t *      $.fn.dataTable.ColReorder( '#example' ).fnOrder().reverse()\n\t *    );\n\t */\n\t\"fnOrder\": function ( set, original )\n\t{\n\t\tvar a = [], i, ien, j, jen;\n\t\tvar columns = this.s.dt.aoColumns;\n\n\t\tif ( set === undefined ){\n\t\t\tfor ( i=0, ien=columns.length ; i<ien ; i++ ) {\n\t\t\t\ta.push( columns[i]._ColReorder_iOrigCol );\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}\n\n\t\t// The order given is based on the original indexes, rather than the\n\t\t// existing ones, so we need to translate from the original to current\n\t\t// before then doing the order\n\t\tif ( original ) {\n\t\t\tvar order = this.fnOrder();\n\n\t\t\tfor ( i=0, ien=set.length ; i<ien ; i++ ) {\n\t\t\t\ta.push( $.inArray( set[i], order ) );\n\t\t\t}\n\n\t\t\tset = a;\n\t\t}\n\n\t\tthis._fnOrderColumns( fnInvertKeyValues( set ) );\n\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Convert from the original column index, to the original\n\t *\n\t * @param  {int|array} idx Index(es) to convert\n\t * @param  {string} dir Transpose direction - `fromOriginal` / `toCurrent`\n\t *   or `'toOriginal` / `fromCurrent`\n\t * @return {int|array}     Converted values\n\t */\n\tfnTranspose: function ( idx, dir )\n\t{\n\t\tif ( ! dir ) {\n\t\t\tdir = 'toCurrent';\n\t\t}\n\n\t\tvar order = this.fnOrder();\n\t\tvar columns = this.s.dt.aoColumns;\n\n\t\tif ( dir === 'toCurrent' ) {\n\t\t\t// Given an original index, want the current\n\t\t\treturn ! Array.isArray( idx ) ?\n\t\t\t\t$.inArray( idx, order ) :\n\t\t\t\t$.map( idx, function ( index ) {\n\t\t\t\t\treturn $.inArray( index, order );\n\t\t\t\t} );\n\t\t}\n\t\telse {\n\t\t\t// Given a current index, want the original\n\t\t\treturn ! Array.isArray( idx ) ?\n\t\t\t\tcolumns[idx]._ColReorder_iOrigCol :\n\t\t\t\t$.map( idx, function ( index ) {\n\t\t\t\t\treturn columns[index]._ColReorder_iOrigCol;\n\t\t\t\t} );\n\t\t}\n\t},\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Private methods (they are of course public in JS, but recommended as private)\n\t * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\t/**\n\t * Constructor logic\n\t *  @method  _fnConstruct\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnConstruct\": function ()\n\t{\n\t\tvar that = this;\n\t\tvar iLen = this.s.dt.aoColumns.length;\n\t\tvar table = this.s.dt.nTable;\n\t\tvar i;\n\n\t\t/* Columns discounted from reordering - counting left to right */\n\t\tif ( this.s.init.iFixedColumns )\n\t\t{\n\t\t\tthis.s.fixed = this.s.init.iFixedColumns;\n\t\t}\n\n\t\tif ( this.s.init.iFixedColumnsLeft )\n\t\t{\n\t\t\tthis.s.fixed = this.s.init.iFixedColumnsLeft;\n\t\t}\n\n\t\t/* Columns discounted from reordering - counting right to left */\n\t\tthis.s.fixedRight = this.s.init.iFixedColumnsRight ?\n\t\t\tthis.s.init.iFixedColumnsRight :\n\t\t\t0;\n\n\t\t/* Drop callback initialisation option */\n\t\tif ( this.s.init.fnReorderCallback )\n\t\t{\n\t\t\tthis.s.reorderCallback = this.s.init.fnReorderCallback;\n\t\t}\n\n\t\t/* Add event handlers for the drag and drop, and also mark the original column order */\n\t\tfor ( i = 0; i < iLen; i++ )\n\t\t{\n\t\t\tif ( i > this.s.fixed-1 && i < iLen - this.s.fixedRight )\n\t\t\t{\n\t\t\t\tthis._fnMouseListener( i, this.s.dt.aoColumns[i].nTh );\n\t\t\t}\n\n\t\t\t/* Mark the original column order for later reference */\n\t\t\tthis.s.dt.aoColumns[i]._ColReorder_iOrigCol = i;\n\t\t}\n\n\t\t/* State saving */\n\t\tthis.s.dt.oApi._fnCallbackReg( this.s.dt, 'aoStateSaveParams', function (oS, oData) {\n\t\t\tthat._fnStateSave.call( that, oData );\n\t\t}, \"ColReorder_State\" );\n\n\t\tthis.s.dt.oApi._fnCallbackReg(this.s.dt, 'aoStateLoadParams', function(oS, oData) {\n\t\t\tthat.s.dt._colReorder.fnOrder(oData.ColReorder, true);\n\t\t})\n\n\t\t/* An initial column order has been specified */\n\t\tvar aiOrder = null;\n\t\tif ( this.s.init.aiOrder )\n\t\t{\n\t\t\taiOrder = this.s.init.aiOrder.slice();\n\t\t}\n\n\t\t/* State loading, overrides the column order given */\n\t\tif ( this.s.dt.oLoadedState && typeof this.s.dt.oLoadedState.ColReorder != 'undefined' &&\n\t\t  this.s.dt.oLoadedState.ColReorder.length == this.s.dt.aoColumns.length )\n\t\t{\n\t\t\taiOrder = this.s.dt.oLoadedState.ColReorder;\n\t\t}\n\n\t\t/* If we have an order to apply - do so */\n\t\tif ( aiOrder )\n\t\t{\n\t\t\t/* We might be called during or after the DataTables initialisation. If before, then we need\n\t\t\t * to wait until the draw is done, if after, then do what we need to do right away\n\t\t\t */\n\t\t\tif ( !that.s.dt._bInitComplete )\n\t\t\t{\n\t\t\t\tvar bDone = false;\n\t\t\t\t$(table).on( 'draw.dt.colReorder', function () {\n\t\t\t\t\tif ( !that.s.dt._bInitComplete && !bDone )\n\t\t\t\t\t{\n\t\t\t\t\t\tbDone = true;\n\t\t\t\t\t\tvar resort = fnInvertKeyValues( aiOrder );\n\t\t\t\t\t\tthat._fnOrderColumns.call( that, resort );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar resort = fnInvertKeyValues( aiOrder );\n\t\t\t\tthat._fnOrderColumns.call( that, resort );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis._fnSetColumnIndexes();\n\t\t}\n\n\t\t// Destroy clean up\n\t\t$(table).on( 'destroy.dt.colReorder', function () {\n\t\t\t// Restore table to original order from when it was loaded\n\t\t\tthat.fnReset();\n\n\t\t\t$(table).off( 'destroy.dt.colReorder draw.dt.colReorder' );\n\n\t\t\t$.each( that.s.dt.aoColumns, function (i, column) {\n\t\t\t\t$(column.nTh).off('.ColReorder');\n\t\t\t\t$(column.nTh).removeAttr('data-column-index');\n\t\t\t} );\n\n\t\t\tthat.s.dt._colReorder = null;\n\t\t\tthat.s = null;\n\t\t} );\n\t},\n\n\n\t/**\n\t * Set the column order from an array\n\t *  @method  _fnOrderColumns\n\t *  @param   array a An array of integers which dictate the column order that should be applied\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnOrderColumns\": function ( a )\n\t{\n\t\tvar changed = false;\n\n\t\tif ( a.length != this.s.dt.aoColumns.length )\n\t\t{\n\t\t\tthis.s.dt.oInstance.oApi._fnLog( this.s.dt, 1, \"ColReorder - array reorder does not \"+\n\t\t\t\t\"match known number of columns. Skipping.\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( var i=0, iLen=a.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tvar currIndex = $.inArray( i, a );\n\t\t\tif ( i != currIndex )\n\t\t\t{\n\t\t\t\t/* Reorder our switching array */\n\t\t\t\tfnArraySwitch( a, currIndex, i );\n\n\t\t\t\t/* Do the column reorder in the table */\n\t\t\t\tthis.s.dt.oInstance.fnColReorder( currIndex, i, true, false );\n\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._fnSetColumnIndexes();\n\n\t\t// Has anything actually changed? If not, then nothing else to do\n\t\tif ( ! changed ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$.fn.dataTable.Api( this.s.dt ).rows().invalidate('data');\n\n\t\t/* When scrolling we need to recalculate the column sizes to allow for the shift */\n\t\tif ( this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\" )\n\t\t{\n\t\t\tthis.s.dt.oInstance.fnAdjustColumnSizing( false );\n\t\t}\n\n\t\t/* Save the state */\n\t\tthis.s.dt.oInstance.oApi._fnSaveState( this.s.dt );\n\n\t\tif ( this.s.reorderCallback !== null )\n\t\t{\n\t\t\tthis.s.reorderCallback.call( this );\n\t\t}\n\t},\n\n\n\t/**\n\t * Because we change the indexes of columns in the table, relative to their starting point\n\t * we need to reorder the state columns to what they are at the starting point so we can\n\t * then rearrange them again on state load!\n\t *  @method  _fnStateSave\n\t *  @param   object oState DataTables state\n\t *  @returns string JSON encoded cookie string for DataTables\n\t *  @private\n\t */\n\t\"_fnStateSave\": function ( oState )\n\t{\n\t\tif(this.s === null) {\n\t\t\treturn;\n\t\t}\n\t\tvar i, iLen, aCopy, iOrigColumn;\n\t\tvar oSettings = this.s.dt;\n\t\tvar columns = oSettings.aoColumns;\n\n\t\toState.ColReorder = [];\n\n\t\t/* Sorting */\n\t\tif ( oState.aaSorting ) {\n\t\t\t// 1.10.0-\n\t\t\tfor ( i=0 ; i<oState.aaSorting.length ; i++ ) {\n\t\t\t\toState.aaSorting[i][0] = columns[ oState.aaSorting[i][0] ]._ColReorder_iOrigCol;\n\t\t\t}\n\n\t\t\tvar aSearchCopy = $.extend( true, [], oState.aoSearchCols );\n\n\t\t\tfor ( i=0, iLen=columns.length ; i<iLen ; i++ )\n\t\t\t{\n\t\t\t\tiOrigColumn = columns[i]._ColReorder_iOrigCol;\n\n\t\t\t\t/* Column filter */\n\t\t\t\toState.aoSearchCols[ iOrigColumn ] = aSearchCopy[i];\n\n\t\t\t\t/* Visibility */\n\t\t\t\toState.abVisCols[ iOrigColumn ] = columns[i].bVisible;\n\n\t\t\t\t/* Column reordering */\n\t\t\t\toState.ColReorder.push( iOrigColumn );\n\t\t\t}\n\t\t}\n\t\telse if ( oState.order ) {\n\t\t\t// 1.10.1+\n\t\t\tfor ( i=0 ; i<oState.order.length ; i++ ) {\n\t\t\t\toState.order[i][0] = columns[ oState.order[i][0] ]._ColReorder_iOrigCol;\n\t\t\t}\n\n\t\t\tvar stateColumnsCopy = $.extend( true, [], oState.columns );\n\n\t\t\tfor ( i=0, iLen=columns.length ; i<iLen ; i++ )\n\t\t\t{\n\t\t\t\tiOrigColumn = columns[i]._ColReorder_iOrigCol;\n\n\t\t\t\t/* Columns */\n\t\t\t\toState.columns[ iOrigColumn ] = stateColumnsCopy[i];\n\n\t\t\t\t/* Column reordering */\n\t\t\t\toState.ColReorder.push( iOrigColumn );\n\t\t\t}\n\t\t}\n\t},\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Mouse drop and drag\n\t */\n\n\t/**\n\t * Add a mouse down listener to a particluar TH element\n\t *  @method  _fnMouseListener\n\t *  @param   int i Column index\n\t *  @param   element nTh TH element clicked on\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnMouseListener\": function ( i, nTh )\n\t{\n\t\tvar that = this;\n\t\t$(nTh)\n\t\t\t.on( 'mousedown.ColReorder', function (e) {\n\t\t\t\tif ( that.s.enable && e.which === 1 ) {\n\t\t\t\t\tthat._fnMouseDown.call( that, e, nTh );\n\t\t\t\t}\n\t\t\t} )\n\t\t\t.on( 'touchstart.ColReorder', function (e) {\n\t\t\t\tif ( that.s.enable ) {\n\t\t\t\t\tthat._fnMouseDown.call( that, e, nTh );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\n\n\t/**\n\t * Mouse down on a TH element in the table header\n\t *  @method  _fnMouseDown\n\t *  @param   event e Mouse event\n\t *  @param   element nTh TH element to be dragged\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnMouseDown\": function ( e, nTh )\n\t{\n\t\tvar that = this;\n\n\t\t/* Store information about the mouse position */\n\t\tvar target = $(e.target).closest('th, td');\n\t\tvar offset = target.offset();\n\t\tvar idx = parseInt( $(nTh).attr('data-column-index'), 10 );\n\n\t\tif ( idx === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.s.mouse.startX = this._fnCursorPosition( e, 'pageX' );\n\t\tthis.s.mouse.startY = this._fnCursorPosition( e, 'pageY' );\n\t\tthis.s.mouse.offsetX = this._fnCursorPosition( e, 'pageX' ) - offset.left;\n\t\tthis.s.mouse.offsetY = this._fnCursorPosition( e, 'pageY' ) - offset.top;\n\t\tthis.s.mouse.target = this.s.dt.aoColumns[ idx ].nTh;//target[0];\n\t\tthis.s.mouse.targetIndex = idx;\n\t\tthis.s.mouse.fromIndex = idx;\n\n\t\tthis._fnRegions();\n\n\t\t/* Add event handlers to the document */\n\t\t$(document)\n\t\t\t.on( 'mousemove.ColReorder touchmove.ColReorder', function (e) {\n\t\t\t\tthat._fnMouseMove.call( that, e );\n\t\t\t} )\n\t\t\t.on( 'mouseup.ColReorder touchend.ColReorder', function (e) {\n\t\t\t\tthat._fnMouseUp.call( that, e );\n\t\t\t} );\n\t},\n\n\n\t/**\n\t * Deal with a mouse move event while dragging a node\n\t *  @method  _fnMouseMove\n\t *  @param   event e Mouse event\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnMouseMove\": function ( e )\n\t{\n\t\tvar that = this;\n\n\t\tif ( this.dom.drag === null )\n\t\t{\n\t\t\t/* Only create the drag element if the mouse has moved a specific distance from the start\n\t\t\t * point - this allows the user to make small mouse movements when sorting and not have a\n\t\t\t * possibly confusing drag element showing up\n\t\t\t */\n\t\t\tif ( Math.pow(\n\t\t\t\tMath.pow(this._fnCursorPosition( e, 'pageX') - this.s.mouse.startX, 2) +\n\t\t\t\tMath.pow(this._fnCursorPosition( e, 'pageY') - this.s.mouse.startY, 2), 0.5 ) < 5 )\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._fnCreateDragNode();\n\t\t}\n\n\t\t/* Position the element - we respect where in the element the click occured */\n\t\tthis.dom.drag.css( {\n\t\t\tleft: this._fnCursorPosition( e, 'pageX' ) - this.s.mouse.offsetX,\n\t\t\ttop: this._fnCursorPosition( e, 'pageY' ) - this.s.mouse.offsetY\n\t\t} );\n\n\t\t/* Based on the current mouse position, calculate where the insert should go */\n\t\tvar target;\n\t\tvar lastToIndex = this.s.mouse.toIndex;\n\t\tvar cursorXPosiotion = this._fnCursorPosition(e, 'pageX');\n\t\tvar targetsPrev = function (i) {\n\t\t\twhile (i >= 0) {\n\t\t\t\ti--;\n\n\t\t\t\tif (i <= 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (that.s.aoTargets[i+1].x !== that.s.aoTargets[i].x) {\n\t\t\t\t\treturn that.s.aoTargets[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tvar firstNotHidden = function () {\n\t\t\tfor (var i=0 ; i<that.s.aoTargets.length-1 ; i++) {\n\t\t\t\tif (that.s.aoTargets[i].x !== that.s.aoTargets[i+1].x) {\n\t\t\t\t\treturn that.s.aoTargets[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tvar lastNotHidden = function () {\n\t\t\tfor (var i=that.s.aoTargets.length-1 ; i>0 ; i--) {\n\t\t\t\tif (that.s.aoTargets[i].x !== that.s.aoTargets[i-1].x) {\n\t\t\t\t\treturn that.s.aoTargets[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n        for (var i = 1; i < this.s.aoTargets.length; i++) {\n\t\t\tvar prevTarget = targetsPrev(i);\n\t\t\tif (! prevTarget) {\n\t\t\t\tprevTarget = firstNotHidden();\n\t\t\t}\n\n\t\t\tvar prevTargetMiddle = prevTarget.x + (this.s.aoTargets[i].x - prevTarget.x) / 2;\n\n            if (this._fnIsLtr()) {\n                if (cursorXPosiotion < prevTargetMiddle ) {\n                    target = prevTarget;\n                    break;\n                }\n            }\n            else {\n                if (cursorXPosiotion > prevTargetMiddle) {\n                    target = prevTarget;\n                    break;\n                }\n            }\n\t\t}\n\n        if (target) {\n            this.dom.pointer.css('left', target.x);\n            this.s.mouse.toIndex = target.to;\n        }\n        else {\n\t\t\t// The insert element wasn't positioned in the array (less than\n\t\t\t// operator), so we put it at the end\n\t\t\tthis.dom.pointer.css( 'left', lastNotHidden().x );\n\t\t\tthis.s.mouse.toIndex = lastNotHidden().to;\n\t\t}\n\n\t\t// Perform reordering if realtime updating is on and the column has moved\n\t\tif ( this.s.init.bRealtime && lastToIndex !== this.s.mouse.toIndex ) {\n\t\t\tthis.s.dt.oInstance.fnColReorder( this.s.mouse.fromIndex, this.s.mouse.toIndex );\n\t\t\tthis.s.mouse.fromIndex = this.s.mouse.toIndex;\n\n\t\t\t// Not great for performance, but required to keep everything in alignment\n\t\t\tif ( this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\" )\n\t\t\t{\n\t\t\t\tthis.s.dt.oInstance.fnAdjustColumnSizing( false );\n\t\t\t}\n\n\t\t\tthis._fnRegions();\n\t\t}\n\t},\n\n\n\t/**\n\t * Finish off the mouse drag and insert the column where needed\n\t *  @method  _fnMouseUp\n\t *  @param   event e Mouse event\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnMouseUp\": function ( e )\n\t{\n\t\tvar that = this;\n\n\t\t$(document).off( '.ColReorder' );\n\n\t\tif ( this.dom.drag !== null )\n\t\t{\n\t\t\t/* Remove the guide elements */\n\t\t\tthis.dom.drag.remove();\n\t\t\tthis.dom.pointer.remove();\n\t\t\tthis.dom.drag = null;\n\t\t\tthis.dom.pointer = null;\n\n\t\t\t/* Actually do the reorder */\n\t\t\tthis.s.dt.oInstance.fnColReorder( this.s.mouse.fromIndex, this.s.mouse.toIndex, true );\n\t\t\tthis._fnSetColumnIndexes();\n\n\t\t\t/* When scrolling we need to recalculate the column sizes to allow for the shift */\n\t\t\tif ( this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\" )\n\t\t\t{\n\t\t\t\tthis.s.dt.oInstance.fnAdjustColumnSizing( false );\n\t\t\t}\n\n\t\t\t/* Save the state */\n\t\t\tthis.s.dt.oInstance.oApi._fnSaveState( this.s.dt );\n\n\t\t\tif ( this.s.reorderCallback !== null )\n\t\t\t{\n\t\t\t\tthis.s.reorderCallback.call( this );\n\t\t\t}\n\t\t}\n\t},\n\n\n\t/**\n\t * Calculate a cached array with the points of the column inserts, and the\n\t * 'to' points\n\t *  @method  _fnRegions\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnRegions\": function ()\n\t{\n\t\tvar aoColumns = this.s.dt.aoColumns;\n        var isLTR = this._fnIsLtr();\n\t\tthis.s.aoTargets.splice(0, this.s.aoTargets.length);\n\t\tvar lastBound = $(this.s.dt.nTable).offset().left;\n\n        var aoColumnBounds = [];\n        $.each(aoColumns, function (i, column) {\n            if (column.bVisible && column.nTh.style.display !== 'none') {\n                var nth = $(column.nTh);\n\t\t\t\tvar bound = nth.offset().left;\n\n                if (isLTR) {\n                    bound += nth.outerWidth();\n                }\n\n                aoColumnBounds.push({\n                    index: i,\n                    bound: bound\n\t\t\t\t});\n\n\t\t\t\tlastBound = bound;\n\t\t\t}\n\t\t\telse {\n                aoColumnBounds.push({\n\t\t\t\t\tindex: i,\n\t\t\t\t\tbound: lastBound\n                });\n\t\t\t}\n\t\t});\n\n        var firstColumn = aoColumnBounds[0];\n\t\tvar firstColumnWidth = $(aoColumns[firstColumn.index].nTh).outerWidth();\n\n        this.s.aoTargets.push({\n            to: 0,\n\t\t\tx: firstColumn.bound - firstColumnWidth\n        });\n\n        for (var i = 0; i < aoColumnBounds.length; i++) {\n            var columnBound = aoColumnBounds[i];\n            var iToPoint = columnBound.index;\n\n            /* For the column / header in question, we want it's position to remain the same if the\n            * position is just to it's immediate left or right, so we only increment the counter for\n            * other columns\n            */\n            if (columnBound.index < this.s.mouse.fromIndex) {\n                iToPoint++;\n            }\n\n            this.s.aoTargets.push({\n\t\t\t\tto: iToPoint,\n                x: columnBound.bound\n            });\n        }\n\n\t\t/* Disallow columns for being reordered by drag and drop, counting right to left */\n\t\tif ( this.s.fixedRight !== 0 )\n\t\t{\n\t\t\tthis.s.aoTargets.splice( this.s.aoTargets.length - this.s.fixedRight );\n\t\t}\n\n\t\t/* Disallow columns for being reordered by drag and drop, counting left to right */\n\t\tif ( this.s.fixed !== 0 )\n\t\t{\n\t\t\tthis.s.aoTargets.splice( 0, this.s.fixed );\n\t\t}\n\t},\n\n\n\t/**\n\t * Copy the TH element that is being drags so the user has the idea that they are actually\n\t * moving it around the page.\n\t *  @method  _fnCreateDragNode\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnCreateDragNode\": function ()\n\t{\n\t\tvar scrolling = this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\";\n\n\t\tvar origCell = this.s.dt.aoColumns[ this.s.mouse.targetIndex ].nTh;\n\t\tvar origTr = origCell.parentNode;\n\t\tvar origThead = origTr.parentNode;\n\t\tvar origTable = origThead.parentNode;\n\t\tvar cloneCell = $(origCell).clone();\n\n\t\t// This is a slightly odd combination of jQuery and DOM, but it is the\n\t\t// fastest and least resource intensive way I could think of cloning\n\t\t// the table with just a single header cell in it.\n\t\tthis.dom.drag = $(origTable.cloneNode(false))\n\t\t\t.addClass( 'DTCR_clonedTable' )\n\t\t\t.append(\n\t\t\t\t$(origThead.cloneNode(false)).append(\n\t\t\t\t\t$(origTr.cloneNode(false)).append(\n\t\t\t\t\t\tcloneCell[0]\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t.css( {\n\t\t\t\tposition: 'absolute',\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0,\n\t\t\t\twidth: $(origCell).outerWidth(),\n\t\t\t\theight: $(origCell).outerHeight()\n\t\t\t} )\n\t\t\t.appendTo( 'body' );\n\n\t\tthis.dom.pointer = $('<div></div>')\n\t\t\t.addClass( 'DTCR_pointer' )\n\t\t\t.css( {\n\t\t\t\tposition: 'absolute',\n\t\t\t\ttop: scrolling ?\n\t\t\t\t\t$($(this.s.dt.nScrollBody).parent()).offset().top :\n\t\t\t\t\t$(this.s.dt.nTable).offset().top,\n\t\t\t\theight : scrolling ?\n\t\t\t\t\t$($(this.s.dt.nScrollBody).parent()).height() :\n\t\t\t\t\t$(this.s.dt.nTable).height()\n\t\t\t} )\n\t\t\t.appendTo( 'body' );\n\t},\n\n\n\t/**\n\t * Add a data attribute to the column headers, so we know the index of\n\t * the row to be reordered. This allows fast detection of the index, and\n\t * for this plug-in to work with FixedHeader which clones the nodes.\n\t *  @private\n\t */\n\t\"_fnSetColumnIndexes\": function ()\n\t{\n\t\t$.each( this.s.dt.aoColumns, function (i, column) {\n\t\t\t$(column.nTh).attr('data-column-index', i);\n\t\t} );\n\t},\n\n\n\t/**\n\t * Get cursor position regardless of mouse or touch input\n\t * @param  {Event}  e    jQuery Event\n\t * @param  {string} prop Property to get\n\t * @return {number}      Value\n\t */\n\t_fnCursorPosition: function ( e, prop ) {\n\t\tif ( e.type.indexOf('touch') !== -1 ) {\n\t\t\treturn e.originalEvent.touches[0][ prop ];\n\t\t}\n\t\treturn e[ prop ];\n    },\n\n    _fnIsLtr: function () {\n        return $(this.s.dt.nTable).css('direction') !== \"rtl\";\n    }\n} );\n\n\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Static parameters\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n/**\n * ColReorder default settings for initialisation\n *  @namespace\n *  @static\n */\nColReorder.defaults = {\n\t/**\n\t * Predefined ordering for the columns that will be applied automatically\n\t * on initialisation. If not specified then the order that the columns are\n\t * found to be in the HTML is the order used.\n\t *  @type array\n\t *  @default null\n\t *  @static\n\t */\n\taiOrder: null,\n\n\t/**\n\t * ColReorder enable on initialisation\n\t *  @type boolean\n\t *  @default true\n\t *  @static\n\t */\n\tbEnable: true,\n\n\t/**\n\t * Redraw the table's column ordering as the end user draws the column\n\t * (`true`) or wait until the mouse is released (`false` - default). Note\n\t * that this will perform a redraw on each reordering, which involves an\n\t * Ajax request each time if you are using server-side processing in\n\t * DataTables.\n\t *  @type boolean\n\t *  @default false\n\t *  @static\n\t */\n\tbRealtime: true,\n\n\t/**\n\t * Indicate how many columns should be fixed in position (counting from the\n\t * left). This will typically be 1 if used, but can be as high as you like.\n\t *  @type int\n\t *  @default 0\n\t *  @static\n\t */\n\tiFixedColumnsLeft: 0,\n\n\t/**\n\t * As `iFixedColumnsRight` but counting from the right.\n\t *  @type int\n\t *  @default 0\n\t *  @static\n\t */\n\tiFixedColumnsRight: 0,\n\n\t/**\n\t * Callback function that is fired when columns are reordered. The `column-\n\t * reorder` event is preferred over this callback\n\t *  @type function():void\n\t *  @default null\n\t *  @static\n\t */\n\tfnReorderCallback: null\n};\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Constants\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * ColReorder version\n *  @constant  version\n *  @type      String\n *  @default   As code\n */\nColReorder.version = \"1.6.2\";\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables interfaces\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n// Expose\n$.fn.dataTable.ColReorder = ColReorder;\n$.fn.DataTable.ColReorder = ColReorder;\n\n\n// Register a new feature with DataTables\nif ( typeof $.fn.dataTable == \"function\" &&\n     typeof $.fn.dataTableExt.fnVersionCheck == \"function\" &&\n     $.fn.dataTableExt.fnVersionCheck('1.10.8') )\n{\n\t$.fn.dataTableExt.aoFeatures.push( {\n\t\t\"fnInit\": function( settings ) {\n\t\t\tvar table = settings.oInstance;\n\n\t\t\tif ( ! settings._colReorder ) {\n\t\t\t\tvar dtInit = settings.oInit;\n\t\t\t\tvar opts = dtInit.colReorder || dtInit.oColReorder || {};\n\n\t\t\t\tnew ColReorder( settings, opts );\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttable.oApi._fnLog( settings, 1, \"ColReorder attempted to initialise twice. Ignoring second\" );\n\t\t\t}\n\n\t\t\treturn null; /* No node for DataTables to insert */\n\t\t},\n\t\t\"cFeature\": \"R\",\n\t\t\"sFeature\": \"ColReorder\"\n\t} );\n}\nelse {\n\talert( \"Warning: ColReorder requires DataTables 1.10.8 or greater - www.datatables.net/download\");\n}\n\n\n// Attach a listener to the document which listens for DataTables initialisation\n// events so we can automatically initialise\n$(document).on( 'preInit.dt.colReorder', function (e, settings) {\n\tif ( e.namespace !== 'dt' ) {\n\t\treturn;\n\t}\n\n\tvar init = settings.oInit.colReorder;\n\tvar defaults = DataTable.defaults.colReorder;\n\n\tif ( init || defaults ) {\n\t\tvar opts = $.extend( {}, init, defaults );\n\n\t\tif ( init !== false ) {\n\t\t\tnew ColReorder( settings, opts  );\n\t\t}\n\t}\n} );\n\n\n// API augmentation\n$.fn.dataTable.Api.register( 'colReorder.reset()', function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._colReorder.fnReset();\n\t} );\n} );\n\n$.fn.dataTable.Api.register( 'colReorder.order()', function ( set, original ) {\n\tif ( set ) {\n\t\treturn this.iterator( 'table', function ( ctx ) {\n\t\t\tctx._colReorder.fnOrder( set, original );\n\t\t} );\n\t}\n\n\treturn this.context.length ?\n\t\tthis.context[0]._colReorder.fnOrder() :\n\t\tnull;\n} );\n\n$.fn.dataTable.Api.register( 'colReorder.transpose()', function ( idx, dir ) {\n\treturn this.context.length && this.context[0]._colReorder ?\n\t\tthis.context[0]._colReorder.fnTranspose( idx, dir ) :\n\t\tidx;\n} );\n\n$.fn.dataTable.Api.register( 'colReorder.move()', function( from, to, drop, invalidateRows ) {\n\tif (this.context.length) {\n\t\tthis.context[0]._colReorder.s.dt.oInstance.fnColReorder( from, to, drop, invalidateRows );\n\t\tthis.context[0]._colReorder._fnSetColumnIndexes();\n\t}\n\treturn this;\n} );\n\n$.fn.dataTable.Api.register( 'colReorder.enable()', function( flag ) {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tif ( ctx._colReorder ) {\n\t\t\tctx._colReorder.fnEnable( flag );\n\t\t}\n\t} );\n} );\n\n$.fn.dataTable.Api.register( 'colReorder.disable()', function() {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tif ( ctx._colReorder ) {\n\t\t\tctx._colReorder.fnDisable();\n\t\t}\n\t} );\n} );\n\n\nexport default DataTable;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}